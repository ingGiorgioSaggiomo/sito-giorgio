# Create the updated HTML file with safe ground spawn for the truck
html = r"""<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bridge Saver – Cartoon FEM-lite (ground safe)</title>
<style>
  :root{
    --ink:#1d1d1f; --good:#34c759; --warn:#ffcf33; --bad:#ff3b30;
    --sky:#bfe3ff; --panel:#ffffff; --muted:#5f6a7a;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--sky);color:var(--ink)}
  /* Toolbar */
  #ui{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;padding:.5rem .75rem;background:#fff;border-bottom:1px solid #ddd;position:sticky;top:0;z-index:10}
  button, select{font-weight:700;border:2px solid var(--ink);background:#fff;border-radius:10px;padding:.5rem .7rem;cursor:pointer;display:inline-flex;align-items:center;gap:.4rem}
  button svg{width:18px;height:18px}
  button:disabled{opacity:.55;cursor:not-allowed}
  .t{display:inline}
  .i{display:none}
  /* Banner */
  #msg{margin:.5rem auto .25rem auto;max-width:980px;background:var(--panel);
       border:2px solid var(--ink);border-radius:12px;padding:.5rem .75rem;
       font-weight:800;text-align:center}
  /* HUD */
  #hud{display:flex;gap:.75rem;align-items:center;justify-content:space-between;max-width:980px;margin:0 auto .25rem auto;padding:0 .75rem;font-size:.9rem}
  .badge{display:inline-block;border:2px solid var(--ink);border-radius:999px;padding:.15rem .55rem;background:#fff}
  /* Canvas wrapper + responsive */
  #wrap{max-width:980px;margin:0 auto .5rem auto}
  canvas{
    width:100%;
    height:calc(100svh - 56px - 64px - 46px - 20px);
    min-height:360px;
    display:block;
    background:#9ad0ff;
    touch-action:none;
  }
  /* Stats panel */
  #statsWrap{max-width:980px;margin:0 auto .75rem auto;padding:0 .75rem}
  details{border:2px solid #ccc;border-radius:10px;background:#fff}
  summary{cursor:pointer;padding:.5rem .75rem;font-weight:800}
  .stats{padding:.5rem .75rem .75rem .75rem;font-size:.92rem;color:#222}
  .muted{color:var(--muted)}

  @media (max-width: 640px){
    #ui{gap:.35rem}
    button, select{padding:.45rem .55rem; font-size:14px}
    #hud{flex-direction:column; align-items:flex-start; gap:.35rem}
    .badge{font-size:12px}
  }
  @media (max-width: 360px){
    .t{display:none}
    .i{display:inline}
  }
</style>
</head>
<body>

<!-- Toolbar -->
<div id="ui" title="Toolbar">
  <button id="btnFixL" title="Vincolo sinistro"><span class="i">
    <!-- pin left -->
    <svg viewBox="0 0 24 24"><path d="M4 3h4v18H4zM8 7h12v2H8zm0 4h10v2H8zm0 4h8v2H8z"/></svg>
  </span><span class="t">Vincolo Sinistro</span></button>

  <button id="btnFixR" title="Vincolo destro"><span class="i">
    <!-- pin right -->
    <svg viewBox="0 0 24 24"><path d="M16 3h4v18h-4zM2 7h14v2H2zm2 4h12v2H4zm4 4h8v2H8z"/></svg>
  </span><span class="t">Vincolo Destro</span></button>

  <label title="Tipo di vincolo"><span class="t">Tipo vincolo</span>
    <select id="supportType">
      <option value="cerniera">Cerniera</option>
      <option value="incastro">Incastro</option>
    </select>
  </label>

  <button id="btnNode" title="Aggiungi nodo"><span class="i">
    <!-- dot -->
    <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="4"/></svg>
  </span><span class="t">Aggiungi Nodo</span></button>

  <button id="btnBeam" title="Aggiungi asta"><span class="i">
    <!-- line -->
    <svg viewBox="0 0 24 24"><path d="M4 18L20 6" stroke="currentColor" stroke-width="3" fill="none"/></svg>
  </span><span class="t">Aggiungi Asta</span></button>

  <button id="btnDelNode" title="Cancella nodo"><span class="i">
    <!-- delete node -->
    <svg viewBox="0 0 24 24"><circle cx="8" cy="12" r="3"/><path d="M13 8h8v2h-8zM13 12h8v2h-8zM13 16h8v2h-8z"/></svg>
  </span><span class="t">Cancella Nodo</span></button>

  <button id="btnUndo" title="Annulla ultima asta"><span class="i">
    <!-- undo -->
    <svg viewBox="0 0 24 24"><path d="M7 7v4H3M3 11a8 8 0 1 0 2.3-5.7" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </span><span class="t">Annulla</span></button>

  <button id="btnRedo" title="Ripristina asta"><span class="i">
    <!-- redo -->
    <svg viewBox="0 0 24 24"><path d="M17 7v4h4M21 11A8 8 0 1 1 18.7 5.3" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </span><span class="t">Ripristina</span></button>

  <button id="btnSave" title="Salva progetto (JSON)"><span class="i">
    <!-- save -->
    <svg viewBox="0 0 24 24"><path d="M5 21h14V7l-4-4H5z" fill="none" stroke="currentColor" stroke-width="2"/><path d="M9 3v6h6V3" stroke="currentColor" stroke-width="2" fill="none"/></svg>
  </span><span class="t">Salva</span></button>

  <label for="fileLoad" title="Carica progetto" style="display:inline-flex;align-items:center;gap:.4rem;border:2px solid var(--ink);border-radius:10px;padding:.5rem .7rem;background:#fff;cursor:pointer;">
    <span class="i">
      <!-- load -->
      <svg viewBox="0 0 24 24"><path d="M12 3v12m0 0l-4-4m4 4l4-4M5 21h14" stroke="currentColor" stroke-width="2" fill="none"/></svg>
    </span><span class="t">Carica</span>
    <input id="fileLoad" type="file" accept="application/json" style="display:none"/>
  </label>

  <button id="btnReset" title="Riavvia progetto (reset)"><span class="i">
    <!-- reset -->
    <svg viewBox="0 0 24 24"><path d="M4 4v6h6M20 20v-6h-6M20 8A8 8 0 1 0 10 20" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </span><span class="t">Reset</span></button>

  <button id="btnStart" title="Avvia simulazione"><span class="i">
    <!-- play -->
    <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
  </span><span class="t">Avvia simulazione</span></button>
</div>

<!-- Banner -->
<div id="msg">Prima di partire progetta il ponte, ingegnere</div>

<!-- HUD -->
<div id="hud">
  <div>Modalità: <span class="badge" id="modeLabel">Inserisci Vincolo Sinistro</span></div>
  <div>Materiale usato: <span id="matLen">0.00</span> m</div>
  <div>Aste rotte: <span id="brokenCnt">0</span></div>
  <div>Stato: <span id="status">In pausa</span></div>
</div>

<!-- Canvas -->
<div id="wrap">
  <canvas id="cv"></canvas>
</div>

<!-- Statistiche -->
<div id="statsWrap">
  <details id="statsDetails">
    <summary>Statistiche ponte</summary>
    <div class="stats">
      <div><strong>Allungamento max:</strong> <span id="sMax">–</span></div>
      <div><strong>Allungamento min:</strong> <span id="sMin">–</span></div>
      <div><strong>Aste integre:</strong> <span id="sOk">0</span> – <strong>rotte:</strong> <span id="sKo">0</span></div>
      <div class="muted" id="sTop">Aste critiche: –</div>
    </div>
  </details>
</div>

<script>
/* ============ Canvas responsive ============ */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
function sizeCanvas(){
  const DPR = Math.min(2, window.devicePixelRatio||1);
  const cssW = Math.max(1, cv.clientWidth);
  const cssH = Math.max(1, cv.clientHeight);
  cv.width  = Math.floor(cssW * DPR);
  cv.height = Math.floor(cssH * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', sizeCanvas, {passive:true});
window.addEventListener('orientationchange', ()=>setTimeout(sizeCanvas, 50), {passive:true});

/* ============ Stato ============ */
const ui = {
  fixL: document.getElementById('btnFixL'),
  fixR: document.getElementById('btnFixR'),
  type: document.getElementById('supportType'),
  node: document.getElementById('btnNode'),
  beam: document.getElementById('btnBeam'),
  delNode: document.getElementById('btnDelNode'),
  undo: document.getElementById('btnUndo'),
  redo: document.getElementById('btnRedo'),
  save: document.getElementById('btnSave'),
  load: document.getElementById('fileLoad'),
  reset: document.getElementById('btnReset'),
  start: document.getElementById('btnStart'),
  modeLabel: document.getElementById('modeLabel'),
  matLen: document.getElementById('matLen'),
  brokenCnt: document.getElementById('brokenCnt'),
  status: document.getElementById('status'),
  msg: document.getElementById('msg'),
  sMax: document.getElementById('sMax'),
  sMin: document.getElementById('sMin'),
  sOk: document.getElementById('sOk'),
  sKo: document.getElementById('sKo'),
  sTop: document.getElementById('sTop')
};

let mode = 'fixL';              // 'fixL'|'fixR'|'node'|'beam'|'del'
let running = false;
let leftSupport = null, rightSupport = null;
let selectFirst = null;
let beamsRedo = [];
let winAccum = 0, score = 0;

const MATERIAL = { steel: { E: 2.0e11, limit: 2.0e8, rho: 7850 } };

const W = {
  g: 9.81,
  damping: 0.995,
  nodes: [],   // {x,y,px,py,fx,fy,mass,fixed,type}
  beams: [],   // {i,j,L0,A,mat,isDeck,broken}
  truck: { x: 0, y: 0, vx: 0, vy: 0, w: 34, h: 18, mass: 260, onDeck: false }
};

const nodeX = i => W.nodes[i].x;
const nodeY = i => W.nodes[i].y;
const rnd = (n,d=2)=>Number(n).toFixed(d);

/* ============ UI binding ============ */
ui.fixL.onclick   = ()=>{ mode='fixL'; ui.modeLabel.textContent='Inserisci Vincolo Sinistro'; };
ui.fixR.onclick   = ()=>{ mode='fixR'; ui.modeLabel.textContent='Inserisci Vincolo Destro'; };
ui.node.onclick   = ()=>{ mode='node'; ui.modeLabel.textContent='Aggiungi Nodo'; };
ui.beam.onclick   = ()=>{ mode='beam'; ui.modeLabel.textContent='Aggiungi Asta'; };
ui.delNode.onclick= ()=>{ mode='del';  ui.modeLabel.textContent='Cancella Nodo'; };
ui.undo.onclick   = ()=> undoBeam();
ui.redo.onclick   = ()=> redoBeam();
ui.reset.onclick  = ()=> hardReset();
ui.start.onclick  = ()=> startSimulation();
ui.save.onclick   = ()=> saveProject();
ui.load.addEventListener('change', onLoadFile);

/* ============ Terreno e hit-test ============ */
function terrainPolys(){
  const w = cv.clientWidth, h = cv.clientHeight;
  const riverY = Math.floor(h*0.68), riverH = Math.floor(h*0.12);

  const left = [
    {x:0, y:riverY+riverH},
    {x:0, y:riverY-140},
    {x:160, y:riverY-40},
    {x:240, y:riverY-10},
    {x:280, y:riverY},
    {x:0, y:riverY}
  ];
  const right = [
    {x:w, y:riverY+riverH},
    {x:w, y:riverY-150},
    {x:w-160, y:riverY-50},
    {x:w-90,  y:riverY-20},
    {x:w-40,  y:riverY},
    {x:w, y:riverY}
  ];
  const rear = [
    {x:0, y:riverY+riverH},
    {x:w, y:riverY+riverH},
    {x:w, y:h},
    {x:0, y:h}
  ];
  const river = [
    {x:0, y:riverY},
    {x:w, y:riverY},
    {x:w, y:riverY+riverH},
    {x:0, y:riverY+riverH}
  ];
  return {left,right,rear,river};
}
function pointInPoly(p, poly){
  let c=false; const x=p.x,y=p.y; const n=poly.length;
  for(let i=0,j=n-1;i<n;j=i++){
    const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y;
    const intersect=((yi>y)!==(yj>y)) && (x<(xj-xi)*(y-yi)/(yj-yi+1e-9)+xi);
    if(intersect) c=!c;
  }
  return c;
}
function isOnTerrain(x,y){
  const {left,right,rear,river} = terrainPolys();
  if(pointInPoly({x,y}, river)) return false;
  return pointInPoly({x,y}, left) || pointInPoly({x,y}, right) || pointInPoly({x,y}, rear);
}

/* ======== Ground profile & safe spawn ======== */
function groundYAt(x){
  const w = cv.clientWidth, h = cv.clientHeight;
  const riverY = Math.floor(h*0.68), riverH = Math.floor(h*0.12);
  const segsLeft = [
    {x0:0,   y0:riverY-140, x1:160, y1:riverY-40},
    {x0:160, y0:riverY-40,  x1:240, y1:riverY-10},
    {x0:240, y0:riverY-10,  x1:280, y1:riverY}
  ];
  const segsRight = [
    {x0:w-160, y0:riverY-50, x1:w-90, y1:riverY-20},
    {x0:w-90,  y0:riverY-20, x1:w-40, y1:riverY}
  ];
  const rearY = riverY + riverH;
  for(const s of segsLeft){
    if(x>=Math.min(s.x0,s.x1) && x<=Math.max(s.x0,s.x1)){
      const t = (x - s.x0) / (s.x1 - s.x0 + 1e-9);
      return s.y0 + t*(s.y1 - s.y0);
    }
  }
  for(const s of segsRight){
    if(x>=Math.min(s.x0,s.x1) && x<=Math.max(s.x0,s.x1)){
      const t = (x - s.x0) / (s.x1 - s.x0 + 1e-9);
      return s.y0 + t*(s.y1 - s.y0);
    }
  }
  if(x>280 && x<(w-40)) return rearY;
  return rearY;
}
function spawnTruckOnGroundLeft(){
  const x = 60; // dentro il pendio sinistro
  const yGround = groundYAt(x);
  W.truck.x = x;
  W.truck.y = yGround - W.truck.h/2;
  W.truck.vx = 0;
  W.truck.vy = 0;
}

/* ============ Input pointer (mouse+touch) ============ */
cv.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  const r = cv.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  if (running && mode!=='del') return;

  if (mode === 'fixL') {
    if (leftSupport !== null) { alert('Il vincolo sinistro è già stato inserito.'); return; }
    if (!isOnTerrain(x,y)) { alert('Posiziona il vincolo sulla terra ferma.'); return; }
    leftSupport = addNode(x, y, true, ui.type.value);
    mode = 'node'; ui.modeLabel.textContent = 'Aggiungi Nodo';
  } else if (mode === 'fixR') {
    if (rightSupport !== null) { alert('Il vincolo destro è già stato inserito.'); return; }
    if (!isOnTerrain(x,y)) { alert('Posiziona il vincolo sulla terra ferma.'); return; }
    rightSupport = addNode(x, y, true, ui.type.value);
    mode = 'node'; ui.modeLabel.textContent = 'Aggiungi Nodo';
  } else if (mode === 'node') {
    addNode(x, y, false);
  } else if (mode === 'beam') {
    const idx = pickNode(x, y);
    if (idx < 0) { selectFirst = null; return; }
    if (selectFirst === null) selectFirst = idx;
    else if (selectFirst !== idx) {
      const isDeck = Math.abs(nodeY(selectFirst) - nodeY(idx)) < 6;
      addBeam(selectFirst, idx, 0.0026, MATERIAL.steel, isDeck);
      selectFirst = null;
    }
  } else if (mode === 'del') {
    const idx = pickNode(x, y);
    if (idx >= 0) deleteNode(idx);
  }
}, {passive:false});

/* ============ Costruzione elementi ============ */
function addNode(x, y, fixed=false, type='cerniera') {
  if (fixed && type!=='cerniera' && type!=='incastro') type = 'cerniera';
  W.nodes.push({ x, y, px:x, py:y, fx:0, fy:0, mass: fixed? 1e9 : 1, fixed, type });
  return W.nodes.length - 1;
}
function pickNode(mx, my) {
  const R = 14;
  return W.nodes.findIndex(n => Math.hypot(n.x - mx, n.y - my) < R);
}
function addBeam(i, j, A=0.0026, mat=MATERIAL.steel, isDeck=false) {
  if (i === j) return;
  if (W.beams.some(b => (b.i===i && b.j===j) || (b.i===j && b.j===i))) return;
  const L0 = Math.hypot(nodeX(j) - nodeX(i), nodeY(j) - nodeY(i));
  W.beams.push({ i, j, L0, A, mat, isDeck, broken:false });
  updateHUD();
}
function undoBeam() { const b = W.beams.pop(); if (b) beamsRedo.push(b); updateHUD(); }
function redoBeam() { const b = beamsRedo.pop(); if (b) W.beams.push(b); updateHUD(); }
function deleteNode(idx){
  W.beams = W.beams.filter(b => b.i!==idx && b.j!==idx)
                   .map(b => ({...b, i: b.i>idx? b.i-1 : b.i, j: b.j>idx? b.j-1 : b.j}));
  if (leftSupport === idx) leftSupport = null;
  if (rightSupport === idx) rightSupport = null;
  if (leftSupport  > idx) leftSupport--;
  if (rightSupport > idx) rightSupport--;
  W.nodes.splice(idx,1);
  updateHUD();
}

/* ============ Fisica ============ */
function step(dt) {
  if (!running) return;

  for (const n of W.nodes) { n.fx = 0; n.fy = n.fixed ? 0 : n.mass * W.g; }

  let brokenCount = 0, totalLen = 0, sMax=-Infinity, sMin=Infinity;
  const strains = [];

  for (const b of W.beams) {
    const ni = W.nodes[b.i], nj = W.nodes[b.j];
    const dx = nj.x - ni.x, dy = nj.y - ni.y;
    const L = Math.hypot(dx, dy) || 1e-6;
    totalLen += L;

    if (b.broken) { brokenCount++; continue; }

    const strain = (L - b.L0) / b.L0;
    const stress = b.mat.E * strain;
    sMax = Math.max(sMax, strain);
    sMin = Math.min(sMin, strain);
    strains.push({idx:b, abs:Math.abs(strain)});

    if (Math.abs(stress) > b.mat.limit) { b.broken = true; brokenCount++; continue; }

    const k = (b.mat.E * b.A) / b.L0;
    const F = k * (L - b.L0) / L;
    const Fx = F * dx, Fy = F * dy;

    if (!ni.fixed) { ni.fx += Fx; ni.fy += Fy; }
    if (!nj.fixed) { nj.fx -= Fx; nj.fy -= Fy; }
  }

  for (const n of W.nodes) {
    if (n.fixed) continue;
    const vx = (n.x - n.px) * W.damping + (n.fx / n.mass) * dt * dt;
    const vy = (n.y - n.py) * W.damping + (n.fy / n.mass) * dt * dt;
    n.px = n.x; n.py = n.y; n.x += vx; n.y += vy;
  }

  // veicolo
  const t = W.truck;
  const seg = deckSegAt(t.x);
  if (seg) {
    const { y:below, dx, dy } = seg;
    const ang = Math.atan2(dy, dx);
    const gAlong = W.g * Math.sin(ang);
    t.vx += gAlong * dt * 50;
    t.vx = clamp(t.vx, -100, 260);
    if (t.y + t.h/2 >= below - 2) { t.y = below - t.h/2; t.vy = 0; t.onDeck = true; }
    else { t.onDeck=false; t.vy += W.g*dt*50; }
  } else { t.onDeck=false; t.vy += W.g*dt*50; }
  t.x += t.vx * dt; t.y += t.vy * dt;

  // vittoria
  if (rightSupport !== null && t.x > W.nodes[rightSupport].x + 20 && brokenCount < W.beams.length) {
    winAccum += dt;
    if (winAccum >= 6) {
      running = false; ui.status.textContent = 'Vittoria';
      calcScore(); setTimeout(()=>alert('Missione completata! Punteggio: '+score), 50);
    }
  } else winAccum = 0;

  // HUD + Stats
  ui.brokenCnt.textContent = brokenCount;
  ui.matLen.textContent = rnd((totalLen/50), 2);
  ui.sMax.textContent = isFinite(sMax)? rnd(sMax,4) : '–';
  ui.sMin.textContent = isFinite(sMin)? rnd(sMin,4) : '–';
  ui.sOk.textContent  = (W.beams.length - brokenCount);
  ui.sKo.textContent  = brokenCount;
  strains.sort((a,b)=>b.abs-a.abs);
  const top = strains.slice(0,3).map(s=>{
    const b = s.idx; return `(${b.i}-${b.j}) ε=${rnd(s.abs,4)}`;
  }).join('  ·  ');
  document.getElementById('sTop').textContent = top || 'Aste critiche: –';
}

function deckSegAt(x) {
  let best = null; let bestW = 1e9;
  for (const b of W.beams) {
    if (!b.isDeck || b.broken) continue;
    const ni = W.nodes[b.i], nj = W.nodes[b.j];
    const minx = Math.min(ni.x, nj.x), maxx = Math.max(ni.x, nj.x);
    if (x >= minx && x <= maxx) {
      const dx = nj.x - ni.x, dy = nj.y - ni.y;
      if (Math.abs(dx) < 1e-6) continue;
      const r = (x - ni.x) / dx;
      const y = ni.y + r * dy;
      const cx = ni.x + r * dx;
      const w = Math.abs(x - cx);
      if (w < bestW) { best = { y, dx, dy }; bestW = w; }
    }
  }
  return best;
}

/* ============ Rendering ============ */
function drawBackground(){
  const w = cv.clientWidth, h = cv.clientHeight;
  // cielo
  ctx.fillStyle = '#9ad0ff'; ctx.fillRect(0,0,w,h);
  // fiume
  const riverY = Math.floor(h*0.68), riverH = Math.floor(h*0.12);
  ctx.fillStyle = '#5bb0ff'; ctx.fillRect(0, riverY, w, riverH);
  // sponda sinistra
  ctx.fillStyle = '#86c36b';
  ctx.beginPath(); ctx.moveTo(0, riverY+riverH);
  ctx.lineTo(0, riverY-140); ctx.lineTo(160, riverY-40);
  ctx.lineTo(240, riverY-10); ctx.lineTo(280, riverY);
  ctx.lineTo(0, riverY); ctx.closePath(); ctx.fill();
  // versante destro
  ctx.beginPath(); ctx.moveTo(w, riverY+riverH);
  ctx.lineTo(w, riverY-150); ctx.lineTo(w-160, riverY-50);
  ctx.lineTo(w-90, riverY-20); ctx.lineTo(w-40, riverY);
  ctx.lineTo(w, riverY); ctx.closePath(); ctx.fill();
  // prato posteriore
  ctx.fillStyle = '#a6d67a'; ctx.fillRect(0, riverY+riverH, w, h-(riverY+riverH));
}

function draw() {
  ctx.clearRect(0,0,cv.width,cv.height);
  drawBackground();

  // aste
  for (const b of W.beams) {
    const ni = W.nodes[b.i], nj = W.nodes[b.j];
    let stroke = '#cfcfcf';
    if (!b.broken) {
      const L = Math.hypot(nj.x-ni.x, nj.y-ni.y);
      const strain = Math.abs((L - b.L0) / b.L0);
      stroke = (strain < 0.01) ? '#34c759' : (strain < 0.03 ? '#ffcf33' : '#ff3b30');
    }
    ctx.strokeStyle = stroke;
    ctx.lineWidth = b.isDeck ? 3 : 2;
    ctx.beginPath(); ctx.moveTo(ni.x, ni.y); ctx.lineTo(nj.x, nj.y); ctx.stroke();
  }

  // nodi
  for (let i=0;i<W.nodes.length;i++) {
    const n = W.nodes[i];
    ctx.fillStyle = n.fixed ? (n.type === 'incastro' ? '#000' : '#444') : '#0a66cc';
    ctx.beginPath(); ctx.arc(n.x, n.y, 5, 0, Math.PI*2); ctx.fill();
    if (n.fixed) {
      ctx.strokeStyle='#000'; ctx.lineWidth=1.2;
      if (n.type === 'cerniera') { ctx.beginPath(); ctx.moveTo(n.x-8, n.y+8); ctx.lineTo(n.x+8, n.y+8); ctx.stroke(); }
      else { ctx.strokeRect(n.x-8, n.y+5, 16, 6); }
    }
  }

  if (selectFirst !== null) {
    const n = W.nodes[selectFirst];
    ctx.setLineDash([6,6]); ctx.strokeStyle='#000'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(n.x, n.y, 9, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
  }

  const t = W.truck;
  ctx.fillStyle = '#ff8c00';
  ctx.fillRect(t.x - t.w/2, t.y - t.h/2, t.w, t.h);
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.arc(t.x - t.w*0.25, t.y + t.h/2, 5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(t.x + t.w*0.25, t.y + t.h/2, 5, 0, Math.PI*2); ctx.fill();
}

/* ============ Loop + HUD + punteggio ============ */
let last = performance.now();
function loop() {
  const now = performance.now();
  const dt = Math.min(0.033, (now - last)/1000);
  last = now;
  step(dt); draw(); updateHUD();
  requestAnimationFrame(loop);
}
function updateHUD() {
  const broken = W.beams.filter(b=>b.broken).length;
  ui.brokenCnt.textContent = broken.toString();
  const L = W.beams.reduce((s,b)=> s + Math.hypot(nodeX(b.j)-nodeX(b.i), nodeY(b.j)-nodeY(b.i)), 0);
  ui.matLen.textContent = rnd(L/50, 2);
  ui.status.textContent = running ? 'In esecuzione' : 'In pausa';
}
function calcScore() {
  const broken = W.beams.filter(b=>b.broken).length;
  const L = W.beams.reduce((s,b)=> s + Math.hypot(nodeX(b.j)-nodeX(b.i), nodeY(b.j)-nodeY(b.i)), 0);
  const base = 1000, matPenalty = L * 0.5, intactBonus = (broken === 0 ? 200 : 0);
  score = Math.max(0, Math.round(base - matPenalty - broken*50 + intactBonus));
}

/* ============ Avvio & Reset ============ */
function startSimulation() {
  if (leftSupport === null || rightSupport === null) {
    alert('Inserisci un vincolo sinistro e uno destro (cerniera/incastro) sulla terra ferma prima di avviare.');
    return;
  }
  // Mantiene posizione a terra; solo velocità iniziale
  W.truck.vx = 40; W.truck.vy = 0;
  running = true; ui.msg.style.display = 'none'; ui.status.textContent = 'In esecuzione';
}
function hardReset(){
  running = false; winAccum = 0; score = 0;
  leftSupport = null; rightSupport = null; selectFirst = null; beamsRedo = [];
  W.nodes = []; W.beams = []; W.truck = { x: 0, y: 0, vx: 0, vy: 0, w: 34, h: 18, mass: 260, onDeck: false };
  mode='fixL'; ui.modeLabel.textContent='Inserisci Vincolo Sinistro';
  ui.msg.style.display = 'block'; ui.status.textContent = 'In pausa';
  spawnTruckOnGroundLeft(); // posiziona in sicurezza
}

/* ============ Salva/Carica JSON ============ */
function saveProject(){
  const data = {
    nodes: W.nodes.map(n=>({x:n.x,y:n.y,fixed:n.fixed,type:n.type})),
    beams: W.beams.map(b=>({i:b.i,j:b.j,L0:b.L0,A:b.A,isDeck:b.isDeck}))
  };
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'ponte_project.json';
  document.body.appendChild(a); a.click(); a.remove();
}
function onLoadFile(ev){
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = () => {
    try{
      const obj = JSON.parse(reader.result);
      hardReset();
      for(const n of obj.nodes||[]) addNode(n.x,n.y,!!n.fixed, n.type||'cerniera');
      for(const b of obj.beams||[]) addBeam(b.i,b.j,b.A||0.0026,MATERIAL.steel,!!b.isDeck);
      ui.msg.style.display='block';
    }catch(err){ alert('File non valido: '+err.message); }
    ev.target.value = '';
  };
  reader.readAsText(f);
}

/* ============ Utility ============ */
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

/* Bootstrap */
sizeCanvas();
spawnTruckOnGroundLeft(); // posiziona in sicurezza sulla terraferma
ui.modeLabel.textContent='Inserisci Vincolo Sinistro';
loop();
</script>
</body>
</html>
"""
path = "/mnt/data/ponte_finale_ground.html"
with open(path, "w", encoding="utf-8") as f:
    f.write(html)
path
