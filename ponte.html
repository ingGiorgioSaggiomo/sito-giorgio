<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Progetta il Ponte Ingegnere! – v8 (collasso se requisiti mancanti)</title>
<style>
  html, body { height: 100%; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans";
    background: #cce6ff;
    overflow: hidden;
  }
  canvas#giocoCanvas{
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    background: #cce6ff;
  }
  #toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255,255,255,0.95);
    padding: 10px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 10;
    flex-wrap: wrap;
    box-shadow: 0 2px 8px rgba(0,0,0,.08);
  }
  button, select {
    padding: 6px 10px;
    font-size: 14px;
    border-radius: 8px;
    border: 1px solid #444;
    cursor: pointer;
    background: #fff;
  }
  .active { outline: 2px solid #0077ff; }
  #pannelloGuida {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 12px;
    border: 2px solid #333;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 20;
    text-align: left;
    max-width: 720px;
    line-height: 1.35;
  }
  #pannelloGuida button {
    margin-top: 15px;
    background-color: #005bbb;
    color: white;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 8px;
    padding: 8px 14px;
  }
  #cronometro, #validator, #requisiti {
    position: absolute;
    right: 10px;
    background: rgba(255,255,255,0.95);
    padding: 8px 12px;
    border-radius: 10px;
    font-weight: 600;
    z-index: 10;
    border: 1px solid #ddd;
    box-shadow: 0 2px 8px rgba(0,0,0,.06);
  }
  #cronometro { top: 10px; font-size: 18px; }
  #validator { top: 52px; font-size: 13px; max-width: 320px; line-height: 1.25; }
  #requisiti { top: 140px; font-size: 12px; max-width: 320px; line-height: 1.2; }
  #validator.ok { border-color: #22aa22; color: #127512; }
  #validator.warn { border-color: #d08a00; color: #7a5300; }
  #validator.bad { border-color: #cc2222; color: #7a1010; }
  #toast {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 64px;
    background: rgba(0,0,0,0.85);
    color: #fff;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 13px;
    display: none;
    z-index: 12;
  }
</style>
<script src="ponte.js"></script>
</head>
<body>
<div id="toolbar">
  <button id="btnNodo">Aggiungi nodo</button>
  <button id="btnDelNodo">Cancella nodo</button>
  <button id="btnVincolo">Vincolo a terra</button>
  <select id="tipoVincolo">
    <option value="cerniera">Cerniera</option>
    <option value="incastro">Incastro</option>
  </select>
  <button id="btnAsta">Aggiungi asta</button>
  <button id="btnPiano">Piano di percorrenza</button>
  <button id="btnAnnulla">Annulla ultima asta</button>
  <button id="btnAvvia">Avvia simulazione</button>
  <button id="btnReset">Reset</button>
</div>

<div id="toast"></div>
<div id="cronometro">Tempo: 0.0s</div>
<div id="validator" class="warn">Piano: nessun tratto</div>
<div id="requisiti">
  Requisiti consigliati per attraversamento:<br>
  • ≥ 3 tratti di piano<br>
  • Catena continua senza ramificazioni<br>
  • Stabilizzazione a triangoli per ogni tratto<br>
  • ≥ 1 vincolo a sinistra e ≥ 1 a destra
</div>

<div id="pannelloGuida">
  <h2>Progetta il Ponte – Stretto di Messina</h2>
  <p><b>Obiettivo</b>: far attraversare il camion su una carreggiata continua stabilizzata con aste reticolari.</p>
  <p><b>Novità v8</b>: se i requisiti non sono rispettati, la simulazione <u>parte comunque</u> e l’opera <b>collassa</b> precipitando in mare (aste e piano di percorrenza).</p>
  <button id="btnHoCapito">Ho capito</button>
</div>

<canvas id="giocoCanvas"></canvas>

<script>
// ===== Stato =====
let guidaMostrata = true;
let canvas, ctx;
let cronometroInterval = null;

let nodi = [];
let aste = [];               // {n1, n2, tipo: "normale"|"piano"}
let vincoli = [];            // {x, y, tipo}
let pianoPercorrenza = [];   // sottoinsieme di aste
let vincoliPosizionati = 0;
const MAX_VINCOLI = 4;

let modalita = "nodo";
let inSimulazione = false;
let inCollasso = false;
let tempoTrascorso = 0;
let timerAttivo = false;
let camion = null;

let audioSplash = null;

const RAGGIO_SELEZIONE = 12;
let nodoSelezionato = null;

const G = 0.45; // gravità per il collasso

// ===== Setup =====
document.addEventListener('DOMContentLoaded', () => {
  canvas = document.getElementById('giocoCanvas');
  ctx = canvas.getContext('2d');
  try { audioSplash = new Audio("splash.mp3"); } catch(e) { audioSplash = null; }

  hookToolbar();
  fitCanvas();
  creaPianettoSinistroVincolato();
  inizializzaCamionSulVersanteSinistro();

  if (guidaMostrata) {
    disegnaSchermataIniziale();
    document.getElementById("pannelloGuida").style.display = "block";
  } else {
    redrawAll();
  }

  document.getElementById("btnHoCapito")?.addEventListener("click", () => {
    document.getElementById("pannelloGuida").style.display = "none";
    guidaMostrata = false; redrawAll();
  });

  canvas.addEventListener("click", onCanvasClick);
  addEventListener('resize', ()=>{ fitCanvas(); redrawAll(); }, {passive:true});
  addEventListener('orientationchange', ()=> setTimeout(()=>{ fitCanvas(); redrawAll(); }, 80), {passive:true});
});

function hookToolbar(){
  const btns = { btnNodo:"nodo", btnDelNodo:"cancellaNodo", btnVincolo:"vincolo", btnAsta:"asta", btnPiano:"piano" };
  for (const [id, mode] of Object.entries(btns)){
    const el = document.getElementById(id);
    el.addEventListener("click", ()=>{ if (!inCollasso) { modalita = mode; evidenziaAttivo(id); } });
  }
  document.getElementById("btnAnnulla").addEventListener("click", () => { 
    if (inCollasso) return;
    if (aste.length){
      const rimossa = aste.pop();
      if (rimossa.tipo === "piano") {
        pianoPercorrenza = pianoPercorrenza.filter(seg => seg !== rimossa);
        aggiornaValidator();
      }
      redrawAll();
    }
  });
  document.getElementById("btnReset").addEventListener("click", resetGioco);
  document.getElementById("btnAvvia").addEventListener("click", () => {
    if (inSimulazione) return;
    const check = valutaRequisiti();
    // v8: si avvia sempre; se non ok, parte collasso
    avviaSimulazione(check.ok);
  });
  evidenziaAttivo("btnNodo");
}
function evidenziaAttivo(id){
  document.querySelectorAll('#toolbar button').forEach(b=> b.classList.remove('active'));
  const el = document.getElementById(id);
  if (el) el.classList.add('active');
}
function showToast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg; t.style.display = "block";
  setTimeout(()=> t.style.display = "none", 1400);
}

// ===== Canvas/Layout =====
function fitCanvas(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const cssW = canvas.clientWidth;
  const cssH = canvas.clientHeight;
  canvas.width  = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function redrawAll(){
  if (guidaMostrata) disegnaSchermataIniziale();
  else {
    disegnaSfondoGioco();
    disegnaAste();
    disegnaNodi();
    disegnaVincoli();
    disegnaCamion(); // sempre sopra tutto
    aggiornaValidator();
  }
}

// ===== Disegno =====
function disegnaSchermataIniziale() {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  ctx.fillStyle = "#cce6ff"; ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "#66cc66";
  ctx.beginPath(); ctx.moveTo(0, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.15, waterTop); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(W, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.85, waterTop); ctx.lineTo(W, H); ctx.closePath(); ctx.fill();

  ctx.fillStyle = "#3399ff"; ctx.fillRect(0, waterTop, W, H - waterTop);

  ctx.fillStyle = "#003b8e"; ctx.font = "700 " + Math.round(H * 0.05) + "px system-ui";
  ctx.textAlign = "center";
  ctx.fillText("Progetta il Ponte sullo Stretto di Messina", W/2, H*0.16);
  ctx.fillStyle = "#102A43"; ctx.font = "400 " + Math.round(H * 0.024) + "px system-ui";
  ctx.fillText("Crea un piano continuo e stabilizzalo con reticolari", W/2, waterTop + 42);

  disegnaCamion();
}
function disegnaSfondoGioco() {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  ctx.fillStyle = "#cce6ff"; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = "#66cc66";
  ctx.beginPath(); ctx.moveTo(0, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.15, waterTop); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(W, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.85, waterTop); ctx.lineTo(W, H); ctx.closePath(); ctx.fill();
  ctx.fillStyle = "#3399ff"; ctx.fillRect(0, waterTop, W, H - waterTop);
}
function disegnaNodi() {
  if (nodoSelezionato) {
    ctx.beginPath(); ctx.arc(nodoSelezionato.x, nodoSelezionato.y, 10, 0, Math.PI*2);
    ctx.strokeStyle = "#0077ff"; ctx.lineWidth = 3; ctx.stroke();
    ctx.beginPath(); ctx.arc(nodoSelezionato.x, nodoSelezionato.y, 4, 0, Math.PI*2);
    ctx.fillStyle = "#0077ff"; ctx.fill();
  }
  ctx.fillStyle = "#000";
  nodi.forEach(n => { ctx.beginPath(); ctx.arc(n.x, n.y, 5, 0, Math.PI*2); ctx.fill(); });
}
function disegnaAste() {
  aste.forEach(a => {
    // durante il collasso sfumiamo leggermente il piano
    const alpha = inCollasso ? 0.9 : 1.0;
    ctx.strokeStyle = (a.tipo === "piano") ? "rgba(170,0,0,"+alpha+")" : "rgba(17,17,17,"+alpha+")";
    ctx.lineWidth = a.tipo === "piano" ? 3 : 1.5;
    ctx.beginPath(); ctx.moveTo(a.n1.x, a.n1.y); ctx.lineTo(a.n2.x, a.n2.y); ctx.stroke();
  });
}
function disegnaVincoli() {
  // I vincoli restano parte del terreno (non cadono)
  vincoli.forEach(v => {
    ctx.fillStyle = v.tipo === "cerniera" ? "#444" : "#222";
    ctx.fillRect(v.x-6, v.y, 12, 22);
  });
}
function disegnaCamion() {
  if (!camion) return;
  // Un piccolo fade quando affonda
  let alpha = 1.0;
  const waterTop = Math.round(canvas.clientHeight * 0.65);
  if (camion.y > waterTop + 20) alpha = Math.max(0, 1 - (camion.y - (waterTop+20)) / 200);
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = "#e53935";
  ctx.fillRect(camion.x, camion.y - camion.altezza, camion.larghezza, camion.altezza);
  // ruote
  ctx.fillStyle = "#222";
  ctx.beginPath(); ctx.arc(camion.x + 4, camion.y, 3.5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(camion.x + camion.larghezza - 4, camion.y, 3.5, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

// ===== Interazione =====
function onCanvasClick(e){
  if (inCollasso) return; // nessuna interazione durante il collasso
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;

  if (modalita === "nodo") { aggiungiNodo(x, y); redrawAll(); return; }
  if (modalita === "cancellaNodo") {
    const n = trovaNodoVicino(x,y); if (!n) { showToast("Nessun nodo da cancellare"); return; }
    cancellaNodo(n); redrawAll(); return;
  }
  if (modalita === "vincolo" && vincoliPosizionati < MAX_VINCOLI) {
    const tipo = document.getElementById("tipoVincolo").value;
    if (eTerraferma(x, y)) {
      const yTerra = getYTerraferma(x);
      vincoli.push({x, y: yTerra, tipo});
      nodi.push({x, y: yTerra, vincolo:true});
      vincoliPosizionati++; redrawAll();
    } else { showToast("I vincoli si posano solo sulla terraferma"); }
    return;
  }
  if (modalita === "asta" || modalita === "piano") {
    const vicino = trovaNodoVicino(x,y);
    if (!vicino) { showToast("Seleziona un nodo esistente"); return; }

    if (!nodoSelezionato) { nodoSelezionato = vicino; redrawAll(); return; }
    const nodo2 = vicino;
    if (nodo2 === nodoSelezionato) { showToast("Scegli un nodo diverso"); return; }

    const tipoAsta = modalita === "piano" ? "piano" : "normale";
    const nuova = {n1: nodoSelezionato, n2: nodo2, tipo: tipoAsta};
    aste.push(nuova);
    if (tipoAsta === "piano") { pianoPercorrenza.push(nuova); aggiornaValidator(); }
    nodoSelezionato = null; redrawAll(); return;
  }
}
function trovaNodoVicino(x,y) { return nodi.find(n => Math.hypot(n.x-x, n.y-y) < RAGGIO_SELEZIONE); }
function aggiungiNodo(x,y) { const n = {x, y}; nodi.push(n); return n; }
function cancellaNodo(nodo){
  aste = aste.filter(a => a.n1 !== nodo && a.n2 !== nodo);
  pianoPercorrenza = pianoPercorrenza.filter(seg => seg.n1 !== nodo && seg.n2 !== nodo);
  if (nodo.vincolo) {
    vincoli = vincoli.filter(v => Math.hypot(v.x - nodo.x, v.y - nodo.y) >= RAGGIO_SELEZIONE);
    vincoliPosizionati = Math.max(0, vincoliPosizionati - 1);
  }
  const idx = nodi.indexOf(nodo); if (idx >= 0) nodi.splice(idx,1);
  if (nodoSelezionato === nodo) nodoSelezionato = null;
  aggiornaValidator();
}

// ===== Camion & pianetto vincolato =====
function inizializzaCamionSulVersanteSinistro(){
  const W = canvas.clientWidth;
  const sinistra = pianoPercorrenza.find(seg => Math.max(seg.n1.x, seg.n2.x) < W * 0.24);
  if (sinistra) {
    const [sx] = segOrd(sinistra);
    camion = {x: sx.x - 18, y: sx.y - 10, vx: 0, vy: 0, larghezza: 22, altezza: 12, affondato:false};
    return;
  }
  const x0 = 20, y0 = getYTerraferma(x0) - 2;
  camion = {x: x0, y: y0, vx: 0, vy: 0, larghezza: 22, altezza: 12, affondato:false};
}
function creaPianettoSinistroVincolato(){
  const W = canvas.clientWidth;
  const xA = Math.max(20, Math.round(W * 0.06));
  const xB = Math.max(xA + 60, Math.round(W * 0.12));
  const yA = getYTerraferma(xA);
  const yB = getYTerraferma(xB);
  const nA = {x:xA, y:yA, vincolo:true};
  const nB = {x:xB, y:yB, vincolo:true};
  nodi.push(nA, nB);
  vincoli.push({x: xA, y: yA, tipo:"cerniera"});
  vincoli.push({x: xB, y: yB, tipo:"cerniera"});
  vincoliPosizionati += 2;
  const seg = {n1:nA, n2:nB, tipo:"piano"};
  aste.push(seg); pianoPercorrenza.push(seg); aggiornaValidator();
}

// ===== Simulazione =====
function avviaSimulazione(requisitiOK) {
  inSimulazione = true; timerAttivo = true; tempoTrascorso = 0;
  if (cronometroInterval) clearInterval(cronometroInterval);
  cronometroInterval = setInterval(() => {
    if (timerAttivo) {
      tempoTrascorso += 0.1;
      document.getElementById("cronometro").innerText = `Tempo: ${tempoTrascorso.toFixed(1)}s`;
    }
  }, 100);

  if (pianoPercorrenza.length > 0) {
    const [sx] = segOrd(pianoPercorrenza[0]);
    camion.x = sx.x - 18; camion.y = sx.y - 10;
    camion.vx = requisitiOK ? 1.2 : 0.0; // se collasso, niente moto orizzontale
    camion.vy = 0;
  } else { camion.vx = 0; camion.vy = 0; }

  if (!requisitiOK) {
    // Avvia il collasso
    inCollasso = true;
    preparaCollasso();
  }

  requestAnimationFrame(loopSimulazione);
}

function loopSimulazione(){
  if (!inSimulazione) return;
  const waterTop = Math.round(canvas.clientHeight * 0.65);

  if (!inCollasso) {
    // modalità precedente
    camion.x += camion.vx;
    const seg = trovaSegmentoPiano(camion.x);
    if (seg) {
      const [a,b] = segOrd(seg);
      const t = (camion.x - a.x) / ((b.x - a.x) || 1e-6);
      const yLine = a.y + t * (b.y - a.y);
      camion.y = yLine - 10;
      camion.vy = (b.y - a.y)/((b.x - a.x) || 1e-6) * camion.vx;
    } else {
      camion.vy += G;
      camion.y += camion.vy;
      if (!camion.affondato && camion.y > waterTop + 5) { camion.affondato = true; splash(); sconfitta(); }
    }
    if (camion.x > canvas.clientWidth * 0.90) { vittoria(); return; }
  } else {
    // aggiornamento collasso
    aggiornaCollasso();
  }

  disegnaSfondoGioco();
  disegnaAste(); disegnaNodi(); disegnaVincoli(); disegnaCamion();
  requestAnimationFrame(loopSimulazione);
}

function trovaSegmentoPiano(xCamion) {
  return pianoPercorrenza.find(seg =>
    (xCamion >= Math.min(seg.n1.x, seg.n2.x) && xCamion <= Math.max(seg.n1.x, seg.n2.x))
  );
}

// ===== Validator strutturale =====
function aggiornaValidator(){
  const el = document.getElementById("validator"); if (!el) return;
  const v = valutaRequisiti();
  el.textContent = v.testo;
  el.className = v.classe;
}

// === Patch: controlli avanzati di stabilità ===
function dofVincolo(t){ return t==="incastro"?3 : t==="cerniera"?2 : 1; }

function buildGraphNonPiano(){
  const g = new Map(); nodi.forEach(n=>g.set(n,[]));
  for (const s of aste) if (s.tipo!=="piano"){ g.get(s.n1).push(s.n2); g.get(s.n2).push(s.n1); }
  return g;
}
function pathToSupport(start, side){ // side: "L","R", or null
  const g=buildGraphNonPiano(), W=canvas.clientWidth, vis=new Set(), q=[start];
  const toLeft = n=> n.x<=W*0.18+2, toRight=n=> n.x>=W*0.82-2;
  while(q.length){
    const n=q.shift(); if(vis.has(n)) continue; vis.add(n);
    if(n.vincolo && (!side || (side==="L"?toLeft(n):toRight(n)))) return true;
    for(const m of g.get(n)) q.push(m);
  }
  return false;
}
function triangoloAncorato(seg){
  const hasBar=(a,b)=>aste.some(s=>s.tipo!=="piano"&&((s.n1===a&&s.n2===b)||(s.n1===b&&s.n2===a)));
  const collin=(A,B,C)=> Math.abs((B.y-A.y)*(C.x-B.x)-(B.x-A.x)*(C.y-B.y))<1e-3;
  function ang(p,q,r){ const u={x:p.x-q.x,y:p.y-q.y}, v={x:r.x-q.x,y:r.y-q.y};
    const cu=u.x*v.x+u.y*v.y, nu=Math.hypot(u.x,u.y), nv=Math.hypot(v.x,v.y);
    const a=Math.acos(Math.min(1,Math.max(-1,cu/(nu*nv)))); return a*180/Math.PI; }
  for(const C of nodi){
    if(C===seg.n1||C===seg.n2) continue;
    const c1=hasBar(C,seg.n1), c2=hasBar(C,seg.n2);
    if(!(c1&&c2) || collin(seg.n1,seg.n2,C)) continue;
    const aA=ang(seg.n2, seg.n1, C), aB=ang(seg.n1, seg.n2, C), aC=ang(seg.n1, C, seg.n2);
    const minA=Math.min(aA,aB,aC);
    const L=[Math.hypot(seg.n1.x-seg.n2.x,seg.n1.y-seg.n2.y),
             Math.hypot(seg.n1.x-C.x,seg.n1.y-C.y),
             Math.hypot(seg.n2.x-C.x,seg.n2.y-C.y)];
    const ratio=Math.max(...L)/Math.min(...L);
    if(minA>=15 && ratio<=5 && pathToSupport(C,null)) return true;
  }
  return false;
}
function checkDeterminacy(){
  const bars = aste.filter(s=>s.tipo!=="piano").length;
  const joints = new Set(aste.filter(s=>s.tipo!=="piano").flatMap(s=>[s.n1,s.n2])).size;
  const reactions = vincoli.reduce((a,v)=>a+dofVincolo(v.tipo),0);
  const val = bars + reactions - 2*joints;
  return {val, bars, joints, reactions};
}
// === Fine patch ===

// ===== Collasso =====
function preparaCollasso(){
  // converti tutti i nodi in particelle dinamiche
  nodi.forEach(n => {
    n.vx = (Math.random()*2 - 1) * 0.8; // leggera spinta laterale
    n.vy = -Math.random()*0.5;          // piccola “staccata” verso l’alto
    n.dyn = true;
  });
  // il camion cade
  camion.vx = 0; camion.vy = 0.2;
}
function aggiornaCollasso(){
  const H = canvas.clientHeight;
  const waterTop = Math.round(H * 0.65);

  // aggiorna i nodi/particelle
  let tuttiAffondati = true;
  nodi.forEach(n => {
    if (!n.dyn) return;
    n.vy += G;
    n.x  += n.vx;
    n.y  += n.vy;
    if (n.y <= H + 40) tuttiAffondati = false;

    // lievissimo attrito in aria
    n.vx *= 0.995;
    // spruzzi quando attraversano il pelo dell'acqua
    if (!n.splash && n.y > waterTop + 2) { n.splash = true; miniSplash(n.x, waterTop); }
  });

  // rompi progressivamente le aste del piano (effetto “cedevolezza”)
  if (pianoPercorrenza.length > 0) {
    if (Math.random() < 0.35) { pianoPercorrenza.pop(); aste = aste.filter(a => a.tipo !== "piano" || pianoPercorrenza.includes(a)); }
  }

  // aggiorna camion (cade)
  camion.vy += G;
  camion.y  += camion.vy;
  if (!camion.affondato && camion.y > waterTop + 5) { camion.affondato = true; splash(); }

  // condizione di fine: quando nodi + camion sono affondati/spariti
  if (tuttiAffondati && camion.affondato) {
    sconfitta();
  }
}

function miniSplash(x, waterTop){
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  for (let i=0; i<6; i++) { ctx.beginPath(); ctx.arc(x + Math.random()*16 - 8, waterTop + 8 + Math.random()*18, Math.random()*3, 0, Math.PI*2); ctx.fill(); }
}

// ===== Effetti / esiti =====
function splash() {
  const H = canvas.clientHeight; if (!camion) return;
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  for (let i=0; i<12; i++) { ctx.beginPath(); ctx.arc(camion.x + Math.random()*20, H*0.65 + 10 + Math.random()*20, Math.random()*5, 0, Math.PI*2); ctx.fill(); }
  if (audioSplash && typeof audioSplash.play === "function") { audioSplash.play().catch(()=>{}); }
}
function vittoria() { inSimulazione = false; inCollasso = false; timerAttivo = false; if (cronometroInterval) { clearInterval(cronometroInterval); cronometroInterval = null; } alert("Vittoria! Attraversamento completato."); }
function sconfitta() { inSimulazione = false; inCollasso = false; timerAttivo = false; if (cronometroInterval) { clearInterval(cronometroInterval); cronometroInterval = null; } alert("Sconfitta! Il ponte è collassato e il camion è caduto in acqua."); document.getElementById("cronometro").innerText = "Tempo: 0.0s"; }

// ===== Terreno/Vincoli =====
function eTerraferma(x, y) {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  const yTerra = getYTerraferma(x);
  const latoSx = (x >= 0 && x <= W*0.18), latoDx = (x >= W*0.82 && x <= W);
  return (latoSx || latoDx) && y >= Math.min(yTerra, waterTop);
}
function getYTerraferma(x) {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  if (x >= 0 && x <= W*0.18) {
    const x0 = 0, y0 = waterTop - Math.min(140, H*0.16);
    const x1 = W*0.15, y1 = waterTop;
    const m = (y1 - y0) / (x1 - x0 + 1e-9);
    return m*(x - x0) + y0;
  }
  if (x >= W*0.82 && x <= W) {
    const x0 = W, y0 = waterTop - Math.min(140, H*0.16);
    const x1 = W*0.85, y1 = waterTop;
    const m = (y1 - y0) / (x1 - x0 + 1e-9);
    return m*(x - x0) + y0;
  }
  return H;
}

// ===== Helpers =====
function segOrd(seg){ return (seg.n1.x <= seg.n2.x) ? [seg.n1, seg.n2] : [seg.n2, seg.n1]; }

// ===== Reset =====
function resetGioco(){
  if (cronometroInterval) { clearInterval(cronometroInterval); cronometroInterval = null; }
  nodi = []; aste = []; vincoli = []; pianoPercorrenza = []; vincoliPosizionati = 0;
  inSimulazione = false; inCollasso = false; tempoTrascorso = 0; timerAttivo = false; nodoSelezionato = null;
  document.getElementById("cronometro").innerText = "Tempo: 0.0s";
  fitCanvas(); creaPianettoSinistroVincolato(); inizializzaCamionSulVersanteSinistro();
  guidaMostrata = false; redrawAll();
}
</script>
</body>
</html>
