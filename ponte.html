<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Progetta il Ponte Ingegnere! – v9</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { height: 100%; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans";
    background: #cce6ff;
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas#giocoCanvas{
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100dvh;
    display: block;
    background: #cce6ff;
    touch-action: none; /* disable browser gestures; handled via Pointer Events */
  }
  #toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    background: rgba(255,255,255,0.95);
    padding: 10px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 10;
    flex-wrap: wrap;
    box-shadow: 0 2px 8px rgba(0,0,0,.08);
    overflow-x: auto;
    max-width: calc(100vw - 20px);
  }
  button, select {
    padding: 10px 16px;
    font-size: 16px;
    border-radius: 10px;
    border: 1px solid #444;
    cursor: pointer;
    background: #fff;
    min-width: 44px;
    min-height: 44px;
  }
  .active { outline: 2px solid #0077ff; }
  @media (max-width: 700px) {
    #toolbar {
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 6px;
      padding: 6px 2px 6px 2px;
      top: 0;
      left: 0;
      right: 0;
      border-radius: 0 0 12px 12px;
      max-width: 100vw;
    }
    button, select {
      font-size: 15px;
      padding: 8px 10px;
      min-width: 40px;
      min-height: 40px;
    }
    #pannelloGuida {
      max-width: 98vw;
      padding: 10px;
      font-size: 15px;
    }
    #cronometro, #validator, #requisiti, #diagnostica {
      right: 2px;
      left: auto;
      font-size: 13px;
      padding: 6px 6px;
      border-radius: 8px;
      max-width: 96vw;
    }
    #cronometro { top: 54px; }
    #validator { top: 92px; max-width: min(94vw, 800px); }
    #requisiti { top: 170px; }
    #diagnostica { top: 270px; }
  }
  #pannelloGuida {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 12px;
    border: 2px solid #333;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 20;
    text-align: left;
    max-width: 760px;
    line-height: 1.35;
  }
  #pannelloGuida button {
    margin-top: 15px;
    background-color: #005bbb;
    color: white;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 8px;
    padding: 8px 14px;
  }
  #cronometro, #validator, #requisiti, #diagnostica {
    position: absolute;
    right: 10px;
    background: rgba(255,255,255,0.95);
    padding: 8px 12px;
    border-radius: 10px;
    font-weight: 600;
    z-index: 10;
    border: 1px solid #ddd;
    box-shadow: 0 2px 8px rgba(0,0,0,.06);
  }
  #cronometro { top: 10px; font-size: 18px; }
  #validator { top: 52px; font-size: 13px; max-width: 340px; line-height: 1.25; }
  #requisiti { top: 140px; font-size: 12px; max-width: 340px; line-height: 1.2; }
  #diagnostica { top: 250px; font-size: 12px; max-width: 340px; line-height: 1.2; display:none; }
  #validator.ok { border-color: #22aa22; color: #127512; }
  #validator.warn { border-color: #d08a00; color: #7a5300; }
  #validator.bad { border-color: #cc2222; color: #7a1010; }
  #toast {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 64px;
    background: rgba(0,0,0,0.85);
    color: #fff;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 13px;
    display: none;
    z-index: 12;
  }

/* === Mobile optimizations & safe-area support === */
:root{
  --sat: env(safe-area-inset-top);
  --sab: env(safe-area-inset-bottom);
  --sal: env(safe-area-inset-left);
  --sar: env(safe-area-inset-right);
}
body {
  overscroll-behavior: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  -webkit-user-select: none;
}
#toolbar {
  top: calc(10px + var(--sat));
  padding-top: calc(6px + var(--sat));
}
@media (max-width: 700px) {
  #toolbar { top: var(--sat); }
}


/* Larger touch targets override */
@media (pointer: coarse) {
  button, select {
    min-width: 48px;
    min-height: 48px;
    font-size: 16px;
  }
}


/* === Mobile layout overrides === */
@media (pointer: coarse) {
  #toolbar {
    position: fixed;
    bottom: calc(8px + var(--sab));
    top: auto;
    left: calc(8px + var(--sal));
    right: calc(8px + var(--sar));
    background: rgba(255,255,255,0.92);
    backdrop-filter: blur(6px);
    box-shadow: 0 8px 24px rgba(0,0,0,.18);
    padding: 8px;
    border-radius: 14px;
    gap: 6px;
    flex-wrap: wrap;
    justify-content: flex-start;
    overflow-x: auto;
  }
  #toolbar button, #toolbar select {
    min-width: 48px;
    min-height: 48px;
    font-size: 16px;
  }
  #cronometro, #validator, #requisiti, #diagnostica {
    left: calc(8px + var(--sal));
    right: auto;
    max-width: min(94vw, 720px);
    font-size: 14px;
  }
  #cronometro { top: calc(8px + var(--sat)); }
  #validator  { top: calc(56px + var(--sat)); }
  #requisiti  { top: calc(138px + var(--sat)); }
  #diagnostica{ top: calc(228px + var(--sat)); }
}


/* === Bottom-sheet toolbar (mobile) === */
@media (pointer: coarse) {
  #toolbar {
    position: fixed;
    inset: auto calc(8px + var(--sar)) calc(8px + var(--sab)) calc(8px + var(--sal));
    border-radius: 16px;
    padding-bottom: calc(8px + max(0px, var(--sab) - 6px));
    max-height: 45vh;
    overflow-y: auto;
    transition: max-height .25s ease, box-shadow .25s ease, transform .25s ease;
  }
  #toolbar.sheet-collapsed {
    max-height: 64px;      /* one row visible */
    overflow-y: hidden;
  }
  #toolbar .sheet-row {
    display: flex; flex-wrap: nowrap; gap: 6px; align-items: center;
  }
  #toolbar .sheet-controls { display: flex; flex-wrap: wrap; gap: 6px; }
  #toolbar .sheet-toggle {
    border: none; outline: none; border-radius: 12px;
    min-width: 44px; min-height: 44px; font-size: 18px;
    background: rgba(0,0,0,0.06);
  }
  #toolbar::after{ /* top handle hint */
    content: "";
    position: absolute;
    top: 6px; left: 50%; transform: translateX(-50%);
    width: 44px; height: 4px; border-radius: 2px;
    background: rgba(0,0,0,.15);
  }
}


/* === Mobile FAB & compact menu === */
@media (pointer: coarse) {
  #toolbar { display: none !important; } /* hide legacy toolbar on mobile */
  #fab {
    position: fixed;
    right: calc(12px + var(--sar));
    bottom: calc(12px + var(--sab));
    width: 56px; height: 56px; border-radius: 28px;
    box-shadow: 0 10px 26px rgba(0,0,0,.25);
    background: #2563eb; color: white; font-size: 26px; line-height: 56px;
    text-align: center; user-select: none; z-index: 9999;
  }
  #fab:active { transform: scale(0.98); }
  #mobileMenu {
    position: fixed;
    right: calc(12px + var(--sar));
    bottom: calc(80px + var(--sab));
    display: none;
    background: rgba(255,255,255,0.98);
    backdrop-filter: blur(6px);
    border-radius: 14px;
    padding: 10px;
    box-shadow: 0 12px 28px rgba(0,0,0,.25);
    z-index: 9998;
  }
  #mobileMenu.open { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  #mobileMenu button, #mobileMenu select {
    min-width: 44px; min-height: 44px; font-size: 16px;
  }
  /* draggable hint */
  #fab::after {
    content: "⋮";
    position: absolute; right: 6px; top: 6px; font-size: 14px; opacity: .7;
  }
  /* auto-hide big validator after 3s on mobile */
  #validator.mobile-autohide { animation: hideVal 0s ease 3s forwards; }
  @keyframes hideVal { to { opacity: 0; visibility: hidden; } }
}

</style>
</head>
<body>
<div id="toolbar">
  <button id="btnNodo">Aggiungi nodo</button>
  <button id="btnDelNodo">Cancella nodo</button>
  <button id="btnVincolo">Vincolo a terra</button>
  <select id="tipoVincolo">
    <option value="cerniera">Cerniera</option>
    <option value="incastro">Incastro</option>
  </select>
  <button id="btnAsta">Aggiungi asta</button>
  <button id="btnPiano">Piano di percorrenza</button>
  <button id="btnAnnulla">Annulla ultima asta</button>
  <button id="btnAvvia">Avvia simulazione</button>
  <button id="btnReset">Reset</button>
  <button id="btnDiag">Diagnostica</button>
  <select id="selDifficolta">
    <option value="facile">Facile</option>
    <option value="medio" selected>Medio</option>
    <option value="difficile">Difficile</option>
  </select>
</div>

<div id="toast"></div>
<div id="cronometro">Tempo: 0.0s</div>
<div id="validator" class="warn">Piano: nessun tratto</div>
<div id="requisiti">
  <b>Requisiti per avvio:</b><br>
  • ≥ 3 tratti di piano, catena continua<br>
  • Triangolazione (aste) per ogni tratto<br>
  • Vincoli a terra su entrambe le coste<br>
  <br>
  <b>Parametri difficoltà:</b><br>
  <u>Tempo massimo</u>: Easy 75 s, Medium 45 s, Hard 30 s<br>
  <u>Pendenza massima</u>: Easy 30%, Medium 22%, Hard 18%<br>
  <u>Angolo giunto</u>: Easy ≈30°, Medium ≈22°, Hard ≈18°<br>
  <u>Freccia ammessa</u>: Easy L/120, Medium L/160, Hard L/200<br>
  <u>Soglia di stallo</u>: 0.40
</div>
<div id="diagnostica"></div>

<div id="pannelloGuida">
  <h2>Progetta il Ponte – Stretto di Messina (v9)</h2>
  <p><b>Novità</b>: condizioni di sconfitta a runtime (freccia, rottura aste, pendenze eccessive, angoli non percorribili, tempo massimo).</p>
  <p><b>Parametri</b> tarabili da menu difficoltà. In “Difficile” la massa del camion varia ±20%, limiti più severi e rischio instabilità maggiore.</p>
  <button id="btnHoCapito">Ho capito</button>
</div>

<canvas id="giocoCanvas"></canvas>

<script>
'use strict';

/* ===== Parametri simulazione (profilati per difficoltà) ===== */
const PRESET = {
  facile: {
  truck: { m: 1200, vx0: 1.8, mu: 0.6 },
    beam:  { E: 2.1e11, A_plane: 0.012, A_bar: 0.008, deltaMaxRatio: 1/120 }, // L/120
  limits:{ slopeMax: 0.30, jointAngleMax: 30 * Math.PI/180, tMax: 75 }, // 30%, ≈30°, 75s
    safety:{ N_tension: 2.2e5, N_comp: 1.8e5, bucklingFactor: 0.9, triBoost: 0.9 },
    noise: { truckMass: 0.0 }
  },
  medio: {
  truck: { m: 1500, vx0: 1.6, mu: 0.5 },
    beam:  { E: 2.1e11, A_plane: 0.010, A_bar: 0.006, deltaMaxRatio: 1/160 }, // L/160
  limits:{ slopeMax: 0.22, jointAngleMax: 22 * Math.PI/180, tMax: 45 }, // 22%, ≈22°, 45s
    safety:{ N_tension: 1.5e5, N_comp: 1.0e5, bucklingFactor: 0.7, triBoost: 0.7 },
    noise: { truckMass: 0.1 }
  },
  difficile: {
  truck: { m: 1700, vx0: 1.3, mu: 0.45 },
    beam:  { E: 2.1e11, A_plane: 0.008, A_bar: 0.005, deltaMaxRatio: 1/200 }, // L/200
  limits:{ slopeMax: 0.18, jointAngleMax: 18 * Math.PI/180, tMax: 30 }, // 18%, ≈18°, 30s
    safety:{ N_tension: 1.2e5, N_comp: 0.8e5, bucklingFactor: 0.6, triBoost: 0.55 },
    noise: { truckMass: 0.2 }
  }
};
let SIM = JSON.parse(JSON.stringify(PRESET.medio));

/* ===== Stato ===== */
let guidaMostrata = true;
let canvas, ctx;
let cronometroInterval = null;

let nodi = [];
let aste = [];               // {n1, n2, tipo: "normale"|"piano", alive:true}
let vincoli = [];            // {x, y, tipo}
let pianoPercorrenza = [];   // sottoinsieme di aste
let vincoliPosizionati = 0;
const MAX_VINCOLI = 4;

let modalita = "nodo";
let inSimulazione = false;
let tempoTrascorso = 0;
let timerAttivo = false;
let camion = null;

let audioSplash = null;

let RAGGIO_SELEZIONE = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ? 22 : 12;
let nodoSelezionato = null;

let stallTimer = 0;


// Utility: allow future dynamic tuning of hit radius (e.g., with zoom)
// Call setHitRadius(f) with a factor in (0.5..2) to scale.
function setHitRadius(f=1){ 
  const base = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ? 22 : 12;
  RAGGIO_SELEZIONE = Math.max(8, Math.min(44, base * f));
}


// === Mobile helpers ===
function addMobileHelpers(){
  const tb = document.getElementById('toolbar');
  if(!tb) return;
  const btnFS = document.createElement('button');
  btnFS.id = 'btnFull';
  btnFS.title = 'Schermo intero';
  btnFS.textContent = '⛶';
  btnFS.addEventListener('click', async ()=>{
    try{
      const root = document.documentElement;
      if (!document.fullscreenElement) { await (root.requestFullscreen?.() || root.webkitRequestFullscreen?.()); }
      else { await (document.exitFullscreen?.() || document.webkitExitFullscreen?.()); }
    }catch(e){ console.warn('fullscreen not available', e); }
  });
  const btnInfo = document.createElement('button');
  btnInfo.id = 'btnInfo';
  btnInfo.title = 'Mostra/Nascondi requisiti';
  btnInfo.textContent = 'ℹ️';
  btnInfo.addEventListener('click', ()=>{
    const r = document.getElementById('requisiti');
    if(!r) return;
    r.style.display = (r.style.display === 'none') ? 'block' : 'none';
  });
  tb.appendChild(btnFS);
  tb.appendChild(btnInfo);
}
// Auto-hide requisiti after first interaction on mobile
let __hidOnce=false;
function autoHideRequisitiOnce(){
  if (__hidOnce) return;
  if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches){
    const r = document.getElementById('requisiti');
    if (r) r.style.display = 'none';
    __hidOnce=true;
  }
}
document.addEventListener('pointerdown', autoHideRequisitiOnce, {passive:true});


// === Bottom sheet installer ===
function installBottomSheet(){
  const tb = document.getElementById('toolbar');
  if(!tb) return;
  tb.classList.add('sheet-collapsed'); // start collapsed on mobile
  // Move existing children into a wrapper so toggle button can sit aside
  const wrap = document.createElement('div');
  wrap.className = 'sheet-controls';
  while (tb.firstChild) wrap.appendChild(tb.firstChild);
  const row = document.createElement('div');
  row.className = 'sheet-row';
  const btnCollapse = document.createElement('button');
  btnCollapse.className = 'sheet-toggle';
  btnCollapse.title = 'Espandi/Riduci comandi';
  const setLabel = ()=> btnCollapse.textContent = tb.classList.contains('sheet-collapsed') ? '⌃' : '⌄';
  setLabel();
  btnCollapse.addEventListener('click', ()=>{
    tb.classList.toggle('sheet-collapsed');
    setLabel();
  });
  row.appendChild(btnCollapse);
  row.appendChild(wrap);
  tb.appendChild(row);

  // Auto collapse when interacting near the bottom area (to liberate gli appoggi)
  const bottomGuard = 140; // px from bottom
  const onPointer = (e)=>{
    if (!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches)) return;
    const y = e.clientY || 0;
    const h = window.innerHeight || document.documentElement.clientHeight;
    if (h - y < bottomGuard && !tb.classList.contains('sheet-collapsed')){
      tb.classList.add('sheet-collapsed');
      setLabel();
    }
  };
  document.addEventListener('pointerdown', onPointer, {passive:true});
  // Collapse when starting actions through canvas click mapping
  const _oc = window.onCanvasClick;
  if (typeof _oc === 'function'){
    window.onCanvasClick = function(ev){
      if (!tb.classList.contains('sheet-collapsed')){
        tb.classList.add('sheet-collapsed'); setLabel();
      }
      return _oc.apply(this, arguments);
    }
  }
}


// === Mobile compact menu logic ===
function buildMobileMenu(){
  if (!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches)) return;
  const fab = document.getElementById('fab');
  const menu = document.getElementById('mobileMenu');
  if (!fab || !menu) return;
  // Mirror the toolbar buttons/select if available
  const tb = document.getElementById('toolbar');
  const controls = [];
  if (tb){
    tb.querySelectorAll('button, select').forEach(el => {
      if (el.id === 'btnFull' || el.id === 'btnInfo') return; // skip desktop helpers
      controls.push(el);
    });
  }
  // Create clones
  controls.forEach(ctrl => {
    let clone;
    if (ctrl.tagName === 'SELECT'){
      clone = document.createElement('select');
      clone.innerHTML = ctrl.innerHTML;
      clone.value = ctrl.value;
      clone.addEventListener('change', ()=> ctrl.value = clone.value);
    } else {
      clone = document.createElement('button');
      clone.textContent = ctrl.textContent || ctrl.value || '...';
      clone.addEventListener('click', (e)=>{ e.preventDefault(); ctrl.click(); closeMenu(); });
    }
    menu.appendChild(clone);
  });
  function toggleMenu(){ menu.classList.toggle('open'); }
  function closeMenu(){ menu.classList.remove('open'); }
  fab.addEventListener('click', (e)=>{ e.preventDefault(); toggleMenu(); });
  // Close on outside tap
  document.addEventListener('pointerdown', (e)=>{
    if (!menu.contains(e.target) && e.target !== fab) closeMenu();
  }, {passive:true});

  // Draggable FAB (and menu follows)
  let dragging=false, sx=0, sy=0, ox=0, oy=0;
  const startDrag = (e)=>{
    dragging=true;
    sx = e.clientX; sy = e.clientY;
    const r = fab.getBoundingClientRect();
    ox = r.left; oy = r.top;
    e.preventDefault();
  };
  const moveDrag = (e)=>{
    if (!dragging) return;
    const nx = ox + (e.clientX - sx);
    const ny = oy + (e.clientY - sy);
    // clamp
    const vw = window.innerWidth, vh = window.innerHeight;
    const w = rW(fab), h = rH(fab);
    const left = Math.max(8, Math.min(vw - w - 8, nx));
    const top  = Math.max(8, Math.min(vh - h - 8, ny));
    fab.style.left = left + 'px';
    fab.style.top  = top + 'px';
    fab.style.right = 'auto';
    fab.style.bottom = 'auto';
    // move menu near fab
    menu.style.right = 'auto';
    menu.style.bottom = 'auto';
    menu.style.left = (left - 4) + 'px';
    menu.style.top  = (top - rH(menu) - 12) + 'px';
  };
  const endDrag = ()=>{ dragging=false; };
  const rW = (el)=> el.getBoundingClientRect().width;
  const rH = (el)=> el.getBoundingClientRect().height;
  fab.addEventListener('pointerdown', startDrag);
  window.addEventListener('pointermove', moveDrag);
  window.addEventListener('pointerup', endDrag);

  // Auto-hide validator message after 3s (mobile)
  const val = document.getElementById('validator');
  if (val){ val.classList.add('mobile-autohide'); }
}
document.addEventListener('DOMContentLoaded', buildMobileMenu);

/* ===== Setup ===== */
document.addEventListener('DOMContentLoaded', () => {
  canvas = document.getElementById('giocoCanvas');
  ctx = canvas.getContext('2d');
  try { audioSplash = new Audio("splash.mp3"); } catch(e) { audioSplash = null; }

  hookToolbar();
  addMobileHelpers();
  installBottomSheet();
  fitCanvas();
  creaPianettoSinistroVincolato();
  inizializzaCamionSulVersanteSinistro();

  if (guidaMostrata) {
    disegnaSchermataIniziale();
    document.getElementById("pannelloGuida").style.display = "block";
  } else {
    redrawAll();
  }

  const btn = document.getElementById("btnHoCapito");
  if (btn) {
    btn.addEventListener("click", () => {
      document.getElementById("pannelloGuida").style.display = "none";
      guidaMostrata = false; redrawAll();
    });
  }

  canvas.addEventListener("click", onCanvasClick);

  // Prefer Pointer Events (covers mouse, touch, pen) and suppress double-firing with 'click'
  let __lastPointerDownTS = 0;
  const __suppressClickCapture = (e) => {
    if (performance.now() - __lastPointerDownTS < 250) { 
      e.stopImmediatePropagation(); 
      e.preventDefault(); 
    }
  };
  // Capture-phase blocker to avoid duplicate onCanvasClick on mobile (pointerdown + click)
  canvas.addEventListener('click', __suppressClickCapture, true);
  canvas.addEventListener('pointerdown', (e) => {
    // Only act on primary pointer or left mouse button
    if (e.isPrimary === false && e.pointerType !== 'mouse') return;
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    __lastPointerDownTS = performance.now();
    const fakeEvent = { clientX: e.clientX, clientY: e.clientY, preventDefault: ()=>{} };
    onCanvasClick(fakeEvent);
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

  // Supporto touch per dispositivi mobili
  /* touchstart handler replaced by pointerdown for mobile */
addEventListener('resize', ()=>{ fitCanvas(); redrawAll(); }, {passive:true});
  addEventListener('orientationchange', ()=> setTimeout(()=>{ fitCanvas(); redrawAll(); }, 80), {passive:true});
});

function hookToolbar(){
  const btns = { btnNodo:"nodo", btnDelNodo:"cancellaNodo", btnVincolo:"vincolo", btnAsta:"asta", btnPiano:"piano" };
  for (const [id, mode] of Object.entries(btns)){
    const el = document.getElementById(id);
    el.addEventListener("click", ()=>{ modalita = mode; evidenziaAttivo(id); });
  }
  document.getElementById("btnAnnulla").addEventListener("click", () => { 
    if (aste.length){
      const rimossa = aste.pop();
      if (rimossa.tipo === "piano") {
        pianoPercorrenza = pianoPercorrenza.filter(seg => seg !== rimossa);
        aggiornaValidator();
      }
      redrawAll();
    }
  });
  document.getElementById("btnReset").addEventListener("click", resetGioco);
  document.getElementById("btnAvvia").addEventListener("click", () => {
    if (inSimulazione) return;
    const check = valutaRequisiti();
    if (!check.ok){
      alert("Impossibile avviare:\n- " + check.messaggi.join("\n- "));
      return;
    }
    preparaDifficolta();
    avviaSimulazione();
  });
  document.getElementById("btnDiag").addEventListener("click", ()=>{
    const d = document.getElementById("diagnostica");
    d.style.display = (d.style.display === "none" || !d.style.display) ? "block" : "none";
  });
  document.getElementById("selDifficolta").addEventListener("change", (e)=>{
    SIM = JSON.parse(JSON.stringify(PRESET[e.target.value]));
    aggiornaValidator();
    showToast("Profilo: " + e.target.value.toUpperCase());
  });
  evidenziaAttivo("btnNodo");
}
function evidenziaAttivo(id){
  document.querySelectorAll('#toolbar button').forEach(b=> b.classList.remove('active'));
  const el = document.getElementById(id);
  if (el) el.classList.add('active');
}
function showToast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg; t.style.display = "block";
  setTimeout(()=> t.style.display = "none", 1400);
}

/* ===== Canvas/Layout ===== */
function fitCanvas(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const cssW = canvas.clientWidth;
  const cssH = canvas.clientHeight;
  canvas.width  = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function redrawAll(){
  if (guidaMostrata) disegnaSchermataIniziale();
  else {
    disegnaSfondoGioco();
    disegnaAste();
    disegnaNodi();
    disegnaVincoli();
    disegnaCamion(); // sopra tutto
    aggiornaValidator();
  }
}

/* ===== Disegno ===== */
function disegnaSchermataIniziale() {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  ctx.fillStyle = "#cce6ff"; ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "#66cc66";
  ctx.beginPath(); ctx.moveTo(0, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.15, waterTop); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(W, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.85, waterTop); ctx.lineTo(W, H); ctx.closePath(); ctx.fill();

  ctx.fillStyle = "#3399ff"; ctx.fillRect(0, waterTop, W, H - waterTop);

  ctx.fillStyle = "#003b8e"; ctx.font = "700 " + Math.round(H * 0.05) + "px system-ui";
  ctx.textAlign = "center";
  ctx.fillText("Progetta il Ponte sullo Stretto di Messina", W/2, H*0.16);
  ctx.fillStyle = "#102A43"; ctx.font = "400 " + Math.round(H * 0.024) + "px system-ui";
  ctx.fillText("Crea un piano continuo e stabilizzalo con reticolari", W/2, waterTop + 42);

  disegnaCamion();
}
function disegnaSfondoGioco() {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  ctx.fillStyle = "#cce6ff"; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = "#66cc66";
  ctx.beginPath(); ctx.moveTo(0, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.15, waterTop); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(W, waterTop - Math.min(140, H*0.16)); ctx.lineTo(W * 0.85, waterTop); ctx.lineTo(W, H); ctx.closePath(); ctx.fill();
  ctx.fillStyle = "#3399ff"; ctx.fillRect(0, waterTop, W, H - waterTop);
}
function disegnaNodi() {
  if (nodoSelezionato) {
    ctx.beginPath(); ctx.arc(nodoSelezionato.x, nodoSelezionato.y, 10, 0, Math.PI*2);
    ctx.strokeStyle = "#0077ff"; ctx.lineWidth = 3; ctx.stroke();
    ctx.beginPath(); ctx.arc(nodoSelezionato.x, nodoSelezionato.y, 4, 0, Math.PI*2);
    ctx.fillStyle = "#0077ff"; ctx.fill();
  }
  ctx.fillStyle = "#000";
  nodi.forEach(n => { ctx.beginPath(); ctx.arc(n.x, n.y, 5, 0, Math.PI*2); ctx.fill(); });
}
function disegnaAste() {
  aste.forEach(a => {
    if (a.alive === false) return;
    ctx.strokeStyle = a.tipo === "piano" ? "#aa0000" : "#111";
    ctx.lineWidth = a.tipo === "piano" ? 3 : 1.5;
    ctx.beginPath(); ctx.moveTo(a.n1.x, a.n1.y); ctx.lineTo(a.n2.x, a.n2.y); ctx.stroke();
  });
}
function disegnaVincoli() {
  vincoli.forEach(v => { ctx.fillStyle = v.tipo === "cerniera" ? "#444" : "#222"; ctx.fillRect(v.x-6, v.y, 12, 22); });
}
function disegnaCamion() {
  if (!camion) return;
  ctx.fillStyle = "#e53935";
  ctx.fillRect(camion.x, camion.y - camion.altezza, camion.larghezza, camion.altezza);
  ctx.fillStyle = "#222";
  ctx.beginPath(); ctx.arc(camion.x + 4, camion.y, 3.5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(camion.x + camion.larghezza - 4, camion.y, 3.5, 0, Math.PI*2); ctx.fill();
}

/* ===== Interazione ===== */
function onCanvasClick(e){
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;

  if (modalita === "nodo") { aggiungiNodo(x, y); redrawAll(); return; }
  if (modalita === "cancellaNodo") {
    const n = trovaNodoVicino(x,y); if (!n) { showToast("Nessun nodo da cancellare"); return; }
    cancellaNodo(n); redrawAll(); return;
  }
  if (modalita === "vincolo" && vincoliPosizionati < MAX_VINCOLI) {
    const tipo = document.getElementById("tipoVincolo").value;
    if (eTerraferma(x, y)) {
      const yTerra = getYTerraferma(x);
      vincoli.push({x, y: yTerra, tipo});
      nodi.push({x, y: yTerra, vincolo:true});
      vincoliPosizionati++; redrawAll();
    } else { showToast("I vincoli si posano solo sulla terraferma"); }
    return;
  }
  if (modalita === "asta" || modalita === "piano") {
    const vicino = trovaNodoVicino(x,y);
    if (!vicino) { showToast("Seleziona un nodo esistente"); return; }

    if (!nodoSelezionato) { nodoSelezionato = vicino; redrawAll(); return; }
    const nodo2 = vicino;
    if (nodo2 === nodoSelezionato) { showToast("Scegli un nodo diverso"); return; }

    const tipoAsta = modalita === "piano" ? "piano" : "normale";
    const nuova = {n1: nodoSelezionato, n2: nodo2, tipo: tipoAsta, alive:true};
    aste.push(nuova);
    if (tipoAsta === "piano") { pianoPercorrenza.push(nuova); aggiornaValidator(); }
    nodoSelezionato = null; redrawAll(); return;
  }
}
function trovaNodoVicino(x,y) { return nodi.find(n => Math.hypot(n.x-x, n.y-y) < RAGGIO_SELEZIONE); }
function aggiungiNodo(x,y) { const n = {x, y}; nodi.push(n); return n; }
function cancellaNodo(nodo){
  aste = aste.filter(a => a.n1 !== nodo && a.n2 !== nodo);
  pianoPercorrenza = pianoPercorrenza.filter(seg => seg.n1 !== nodo && seg.n2 !== nodo);
  if (nodo.vincolo) {
    vincoli = vincoli.filter(v => Math.hypot(v.x - nodo.x, v.y - nodo.y) >= RAGGIO_SELEZIONE);
    vincoliPosizionati = Math.max(0, vincoliPosizionati - 1);
  }
  const idx = nodi.indexOf(nodo); if (idx >= 0) nodi.splice(idx,1);
  if (nodoSelezionato === nodo) nodoSelezionato = null;
  aggiornaValidator();
}

/* ===== Camion & pianetto vincolato ===== */
function inizializzaCamionSulVersanteSinistro(){
  const W = canvas.clientWidth;
  const sinistra = pianoPercorrenza.find(seg => Math.max(seg.n1.x, seg.n2.x) < W * 0.24);
  if (sinistra) {
    const [sx] = segOrd(sinistra);
    camion = {x: sx.x - 18, y: sx.y - 10, vx: 0, vy: 0, larghezza: 22, altezza: 12};
    return;
  }
  const x0 = 20, y0 = getYTerraferma(x0) - 2;
  camion = {x: x0, y: y0, vx: 0, vy: 0, larghezza: 22, altezza: 12};
}
function creaPianettoSinistroVincolato(){
  const W = canvas.clientWidth;
  const xA = Math.max(20, Math.round(W * 0.06));
  const xB = Math.max(xA + 60, Math.round(W * 0.12));
  const yA = getYTerraferma(xA);
  const yB = getYTerraferma(xB);
  const nA = {x:xA, y:yA, vincolo:true};
  const nB = {x:xB, y:yB, vincolo:true};
  nodi.push(nA, nB);
  vincoli.push({x: xA, y: yA, tipo:"cerniera"});
  vincoli.push({x: xB, y: yB, tipo:"cerniera"});
  vincoliPosizionati += 2;
  const seg = {n1:nA, n2:nB, tipo:"piano", alive:true};
  aste.push(seg); pianoPercorrenza.push(seg); aggiornaValidator();
}

/* ===== Simulazione (con fallimenti runtime) ===== */
function preparaDifficolta(){
  if (!camion) camion = {x:0,y:0,vx:0,vy:0,larghezza:22,altezza:12};
  // massa con rumore
  const noise = (Math.random()*2 - 1) * SIM.noise.truckMass;
  camion.m = SIM.truck.m * (1 + noise);
  camion.vx = SIM.truck.vx0;
  stallTimer = 0;
}
function avviaSimulazione() {
  inSimulazione = true; timerAttivo = true; tempoTrascorso = 0;
  if (cronometroInterval) clearInterval(cronometroInterval);
  cronometroInterval = setInterval(() => {
    if (timerAttivo) {
      tempoTrascorso += 0.1;
      document.getElementById("cronometro").innerText = `Tempo: ${tempoTrascorso.toFixed(1)}s`;
      if (tempoTrascorso > SIM.limits.tMax) { sconfitta("Tempo massimo superato"); }
    }
  }, 100);

  if (pianoPercorrenza.length > 0) {
    const [sx] = segOrd(pianoPercorrenza[0]);
    camion.x = sx.x - 18; camion.y = sx.y - 10; camion.vy = 0;
  }
  requestAnimationFrame(loopSimulazione);
}

function loopSimulazione() {
  if (!inSimulazione) return;

  // Movimento camion con attrito e pendenza
  const seg = trovaSegmentoPiano(camion.x);
  const waterTop = Math.round(canvas.clientHeight * 0.65);

  if (seg && seg.alive !== false) {
    const [a,b] = segOrd(seg);
    const L = Math.hypot(b.x - a.x, b.y - a.y);
    const slope = (b.y - a.y) / ((b.x - a.x) || 1e-6);

    // velocità adattiva: proiezione semplice lungo la pendenza
    const g = 9.81, mu = SIM.truck.mu;
    const sinTheta = slope / Math.sqrt(1 + slope*slope);
    const cosTheta = 1 / Math.sqrt(1 + slope*slope);
    const acc = g*(sinTheta - mu*cosTheta);
    camion.vx += acc * 0.05; // dt ~0.05 s
  camion.vx = Math.max(0.2, Math.min(camion.vx, 4.0)); // clamp

    // rimosso: stallo per pendenza eccessiva
    if (Math.abs(slope) > SIM.limits.slopeMax && camion.vx <= 0.25) {
      stallTimer += 0.05;
      // nessuna sconfitta, il camion resta fermo
    } else { stallTimer = 0; }

    // clamp del camion sul piano
    camion.x += camion.vx;
    const t = (camion.x - a.x) / ((b.x - a.x) || 1e-6);
    const yLine = a.y + t * (b.y - a.y);
    camion.y = yLine - 10;
    camion.vy = slope * camion.vx;

    // --- verifiche runtime su questo tratto ---
    // 1) freccia ammessa (deflessione elastica semplificata)
    const F = (camion.m||SIM.truck.m) * g * 0.5; // metà per ruota virtuale
    const triCount = contaTriangoli(seg);
    const triBoost = 1 + SIM.safety.triBoost * triCount;
    const k_eff = SIM.beam.E * SIM.beam.A_plane / (L || 1e-6) * triBoost;
    const delta = F / (k_eff || 1e-6);
    const deltaMax = L * SIM.beam.deltaMaxRatio;
    aggiornaDiagnostica(`Δ=${delta.toFixed(3)} (limite ${deltaMax.toFixed(3)})  |  Tri=${triCount}  |  vx=${camion.vx.toFixed(2)}`);
    if (delta > deltaMax) {
      seg.alive = false;
      pianoPercorrenza = pianoPercorrenza.filter(s => s.alive !== false);
      showToast("Cedimento del piano: Δ oltre il limite");
    }

    // 2) stress aste adiacenti (stima grezza)
    rompiAsteSeSuperanoLimite(seg, F, L);

    // 3) angolo di giunto: quando vicino al nodo b valuta discontinuità
    if (t > 0.95) {
      const next = trovaProssimoSegmentoPiano(b);
      if (next) {
        const ang = angoloTraSegmenti(seg, next);
        if (Math.abs(ang) > SIM.limits.jointAngleMax) {
          sconfitta("Discontinuità eccessiva tra tratti"); return;
        }
      }
    }

  } else {
    // non su piano → caduta
    camion.vy += 0.45;
    camion.y += camion.vy;
    camion.x += Math.max(0.2, camion.vx*0.95);
    if (camion.y > waterTop + 5) { splash(); sconfitta("Carreggiata assente: caduta"); return; }
  }

  // vittoria
  if (camion.x > canvas.clientWidth * 0.90) { vittoria(); return; }

  // disegno
  disegnaSfondoGioco();
  disegnaAste(); disegnaNodi(); disegnaVincoli(); disegnaCamion();
  aggiornaValidator();

  requestAnimationFrame(loopSimulazione);
}

/* ===== Helpers runtime ===== */
function contaTriangoli(seg){
  let count = 0;
  const hasBar = (a,b) => aste.some(s => s.alive !== false && s.tipo !== "piano" && ((s.n1===a && s.n2===b)||(s.n1===b && s.n2===a)));
  const collinear = (A,B,C)=> Math.abs((B.y-A.y)*(C.x-B.x) - (B.x-A.x)*(C.y-B.y)) < 1e-3;
  for (const p of nodi){
    if (p===seg.n1 || p===seg.n2) continue;
    const c1 = hasBar(p, seg.n1), c2 = hasBar(p, seg.n2);
    if ((c1 && c2) && !collinear(seg.n1, seg.n2, p)) count++;
  }
  return count;
}
function rompiAsteSeSuperanoLimite(seg, F, L){
  // proietta forza sulle aste che formano triangoli con il tratto
  const bars = aste.filter(s => s.alive !== false && s.tipo !== "piano" &&
    (s.n1===seg.n1 || s.n2===seg.n1 || s.n1===seg.n2 || s.n2===seg.n2));
  bars.forEach(bar => {
    const len = Math.hypot(bar.n2.x - bar.n1.x, bar.n2.y - bar.n1.y);
    const cos = Math.abs(( (seg.n2.x - seg.n1.x)*(bar.n2.x - bar.n1.x) + (seg.n2.y - seg.n1.y)*(bar.n2.y - bar.n1.y) ) / ((L*len) || 1e-6));
    const N = F * cos; // stima grezza della componente assiale
    const Ncomp = SIM.safety.N_comp * SIM.safety.bucklingFactor * (1.0 / (len/100 + 1)); // buckling peggiora con lunghezza
    const limit = Math.max(SIM.safety.N_tension, Ncomp);
    if (N > limit) { bar.alive = false; showToast("Rottura asta per supero sforzo"); }
  });
}
function trovaProssimoSegmentoPiano(node){
  return pianoPercorrenza.find(s => (s.n1===node || s.n2===node) && s.alive !== false);
}
function angoloTraSegmenti(s1, s2){
  const v1 = {x: s1.n2.x - s1.n1.x, y: s1.n2.y - s1.n1.y};
  const v2 = {x: s2.n2.x - s2.n1.x, y: s2.n2.y - s2.n1.y};
  const dot = v1.x*v2.x + v1.y*v2.y;
  const m1 = Math.hypot(v1.x, v1.y), m2 = Math.hypot(v2.x, v2.y);
  return Math.acos(Math.max(-1, Math.min(1, dot / ((m1*m2)||1e-6))));
}

function trovaSegmentoPiano(xCamion) {
  return pianoPercorrenza.find(seg => seg.alive !== false &&
    (xCamion >= Math.min(seg.n1.x, seg.n2.x) && xCamion <= Math.max(seg.n1.x, seg.n2.x))
  );
}

/* ===== Validator strutturale prima dell'avvio ===== */
function aggiornaValidator(){
  const el = document.getElementById("validator"); if (!el) return;
  const v = valutaRequisiti();
  el.textContent = v.testo;
  el.className = v.classe;
}
function valutaRequisiti(){
  const messaggi = [];
  if (pianoPercorrenza.length === 0) return {ok:false, testo:"Piano: nessun tratto", classe:"warn", messaggi:["Nessun tratto di piano"]};
  const degree = new Map(); const allNodes = new Set();
  pianoPercorrenza.forEach(seg => { if (seg.alive === false) return; allNodes.add(seg.n1); allNodes.add(seg.n2); degree.set(seg.n1,(degree.get(seg.n1)||0)+1); degree.set(seg.n2,(degree.get(seg.n2)||0)+1); });
  const branching = [...degree.values()].some(d => d > 2);
  const adj = new Map(); allNodes.forEach(n => adj.set(n, []));
  pianoPercorrenza.forEach(seg => { if (seg.alive === false) return; adj.get(seg.n1).push(seg.n2); adj.get(seg.n2).push(seg.n1); });
  const start = [...allNodes][0]; const visited = new Set();
  (function dfs(n){ if (visited.has(n)) return; visited.add(n); adj.get(n).forEach(m=>dfs(m)); })(start);
  const connected = visited.size === allNodes.size;
  const endpoints = [...degree.entries()].filter(([n,d]) => d===1).map(([n])=>n);
  const W = canvas.clientWidth;
  const toLeft = (n)=> n.x <= W*0.18 + 2, toRight = (n)=> n.x >= W*0.82 - 2;
  const touchesLeft = [...allNodes].some(toLeft), touchesRight = [...allNodes].some(toRight);
  const lenOK = pianoPercorrenza.filter(s=>s.alive!==false).length >= 3;
  if (!connected) messaggi.push("Piano non connesso");
  if (branching) messaggi.push("Ramificazioni sul piano");
  if (!lenOK) messaggi.push("Meno di 3 tratti di piano");
  const trianglesMissing = pianoPercorrenza.filter(seg => seg.alive!==false && !esisteTriangolazionePerSegmento(seg));
  if (trianglesMissing.length) messaggi.push("Manca triangolazione su uno o più tratti");
  const supportsLeft = nodi.some(n => n.vincolo && toLeft(n));
  const supportsRight = nodi.some(n => n.vincolo && toRight(n));
  if (!supportsLeft) messaggi.push("Nessun vincolo a terra lato sinistro");
  if (!supportsRight) messaggi.push("Nessun vincolo a terra lato destro");
  const ok = connected && !branching && lenOK && trianglesMissing.length===0 && supportsLeft && supportsRight;
  let testo, classe;
  if (ok) { testo = "Piano: CONTINUO e STABILIZZATO – pronto all'avvio"; classe = "ok"; }
  else if (!connected || branching) { testo = "Piano: interrotto o ramificato"; classe = "bad"; }
  else { testo = "Piano: incompleto – " + messaggi.join("; "); classe = "warn"; }
  return {ok, testo, classe, messaggi};
}
function esisteTriangolazionePerSegmento(seg){
  const hasBar = (a,b) => aste.some(s => s.alive !== false && s.tipo !== "piano" && ((s.n1===a && s.n2===b)||(s.n1===b && s.n2===a)));
  const collinear = (A,B,C)=> Math.abs((B.y-A.y)*(C.x-B.x) - (B.x-A.x)*(C.y-B.y)) < 1e-3;
  for (const p of nodi){
    if (p===seg.n1 || p===seg.n2) continue;
    const c1 = hasBar(p, seg.n1), c2 = hasBar(p, seg.n2);
    if ((c1 && c2) && !collinear(seg.n1, seg.n2, p)) return true;
  }
  return false;
}

/* ===== Effetti / esiti ===== */
function aggiornaDiagnostica(txt){ const d = document.getElementById("diagnostica"); d.textContent = txt; }
function splash() {
  const H = canvas.clientHeight; if (!camion) return;
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  for (let i=0; i<12; i++) { ctx.beginPath(); ctx.arc(camion.x + Math.random()*20, H*0.65 + 10 + Math.random()*20, Math.random()*5, 0, Math.PI*2); ctx.fill(); }
  try { audioSplash?.play?.(); } catch(e){}
}
function vittoria() {
  inSimulazione = false; timerAttivo = false; if (cronometroInterval) { clearInterval(cronometroInterval); cronometroInterval = null; }
  alert("Vittoria! Attraversamento completato.");
}
function sconfitta(msg) {
  inSimulazione = false; timerAttivo = false; if (cronometroInterval) { clearInterval(cronometroInterval); cronometroInterval = null; }
  alert("Sconfitta! " + (msg||"Il camion è caduto in acqua."));
  document.getElementById("cronometro").innerText = "Tempo: 0.0s";
}

/* ===== Terreno/Vincoli ===== */
function eTerraferma(x, y) {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  const yTerra = getYTerraferma(x);
  const latoSx = (x >= 0 && x <= W*0.18), latoDx = (x >= W*0.82 && x <= W);
  return (latoSx || latoDx) && y >= Math.min(yTerra, waterTop);
}
function getYTerraferma(x) {
  const W = canvas.clientWidth, H = canvas.clientHeight, waterTop = Math.round(H * 0.65);
  if (x >= 0 && x <= W*0.18) {
    const x0 = 0, y0 = waterTop - Math.min(140, H*0.16);
    const x1 = W*0.15, y1 = waterTop;
    const m = (y1 - y0) / (x1 - x0 + 1e-9);
    return m*(x - x0) + y0;
  }
  if (x >= W*0.82 && x <= W) {
    const x0 = W, y0 = waterTop - Math.min(140, H*0.16);
    const x1 = W*0.85, y1 = waterTop;
    const m = (y1 - y0) / (x1 - x0 + 1e-9);
    return m*(x - x0) + y0;
  }
  return H;
}

/* ===== Helpers ===== */
function segOrd(seg){ return (seg.n1.x <= seg.n2.x) ? [seg.n1, seg.n2] : [seg.n2, seg.n1]; }

/* ===== Reset ===== */
function resetGioco(){
  if (cronometroInterval) { clearInterval(cronometroInterval); cronometroInterval = null; }
  nodi = []; aste = []; vincoli = []; pianoPercorrenza = []; vincoliPosizionati = 0;
  inSimulazione = false; tempoTrascorso = 0; timerAttivo = false; nodoSelezionato = null;
  document.getElementById("cronometro").innerText = "Tempo: 0.0s";
  fitCanvas(); creaPianettoSinistroVincolato(); inizializzaCamionSulVersanteSinistro();
  guidaMostrata = false; redrawAll();
}
</script>

<!-- Mobile FAB and compact menu -->
<div id="fab" title="Comandi">＋</div>
<div id="mobileMenu" aria-label="Comandi ponte"></div>

</body>
</html>
